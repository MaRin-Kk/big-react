(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.index = global.index || {}, global.index.js = factory()));
})(this, (function () { 'use strict';

  const NoFlags = 0b0000000;
  const Placement = 0b0000001;
  const Update = 0b0000010;
  const childDeletion = 0b0000100;
  const MutationMask = Placement | Update | childDeletion;

  const FuntionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  const HostText = 6;

  class FiberNode {
      type;
      tag;
      pendingProps;
      key;
      stateNode;
      ref;
      return;
      sibling;
      child;
      index;
      memoizedProps;
      memoizedState;
      alternate;
      flags;
      subtreeFlags;
      updateQueue;
      current;
      constructor(tag, pendingProps, key) {
          // 实例
          this.tag = tag;
          this.key = key;
          // HostComponent  div DOM
          this.stateNode = null;
          // FuntionComonent  ()=>{}
          this.type = null;
          // 树状结构
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          // 工作单元
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.memoizedState = null;
          this.updateQueue = null;
          this.alternate = null;
          // 副作用
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
      }
  }
  class FiberRootNode {
      container;
      current;
      finshedWork;
      constructor(container, hostRooterFiber) {
          this.container = container;
          this.current = hostRooterFiber;
          hostRooterFiber.stateNode = this;
          this.finshedWork = null;
      }
  }
  const creatWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate;
      if (wip === null) {
          // mount
          wip = new FiberNode(current.tag, pendingProps, current.key);
          wip.type = current.type;
          wip.stateNode = current.stateNode;
          wip.alternate = current;
          current.alternate = wip;
      }
      else {
          // update
          wip.pendingProps = pendingProps;
          wip.flags = NoFlags;
          wip.subtreeFlags = NoFlags;
          wip.type = current.type;
          wip.updateQueue = current.updateQueue;
          wip.child = current.child;
          wip.memoizedProps = current.memoizedProps;
          wip.memoizedState = current.memoizedState;
      }
      return wip;
  };
  function creatFiberFromElement(element) {
      const { type, key, props } = element;
      let fiberTag = FuntionComponent;
      if (typeof type === 'string') {
          fiberTag = HostComponent;
      }
      else if (typeof type !== 'function' && __DEV__) {
          console.warn('未定义的type类型', element);
      }
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  }

  const creatUpdate = (action) => {
      return {
          action
      };
  };
  const creatUpdateQueue = () => {
      return {
          shared: {
              pending: null
          }
      };
  };
  // 增加update
  const enqueueUpdate = (updateQueue, update) => {
      updateQueue.shared.pending = update;
  };
  // 正在消费的update
  const processUpdateQueue = (baseUpdate, pendingUpdate) => {
      const result = { memoizedState: baseUpdate };
      if (pendingUpdate) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              result.memoizedState = action(baseUpdate);
          }
          else {
              result.memoizedState = action;
          }
      }
      return result;
  };

  const supportSymbol = typeof Symbol === 'function' && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol ? Symbol.for('react.element') : 0xeac7;

  function ChildReconciler(shoukdTrackEffects) {
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          // 根据element 创建fiber 返回
          const fiber = creatFiberFromElement(element);
          fiber.return = returnFiber;
          return fiber;
      }
      function reconcileTextNode(returnFiber, currentFiber, content) {
          // 根据element 创建fiber 返回
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      function placeSingleChild(fiber) {
          if (shoukdTrackEffects && fiber.alternate) {
              // 首屏渲染
              fiber.flags |= Placement;
          }
          return fiber;
      }
      return function recocileChildFibers(returnFiber, currentFiber, newChild) {
          // 判断fiber的类型
          if (typeof newChild === 'object' && newChild !== null) {
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      if (__DEV__) {
                          console.warn('未实现的reconcile类型', newChild);
                      }
                      break;
              }
          }
          // 多节点的情况 ul > li * 3
          // HostText
          if (typeof newChild === 'string' || typeof newChild === 'number') {
              return placeSingleChild(reconcileTextNode(returnFiber, currentFiber, newChild));
          }
          return null;
      };
  }
  const recocileChildFibers = ChildReconciler(true);
  const mountChildFibers = ChildReconciler(false);

  function renderWithHooks(wip) {
      const Component = wip.type;
      const props = wip.pendingProps;
      const children = Component(props);
      return children;
  }

  const beginWork = (wip) => {
      // 比较子fiberNode
      switch (wip.tag) {
          case HostRoot:
              return updateHostRoot(wip);
          case HostComponent:
              return updateHostComponent(wip);
          case HostText:
              return null;
          case FuntionComponent:
              return updateFuntionComponent(wip);
          default:
              if (__DEV__) {
                  console.warn('beginWork未实现的类型');
              }
              break;
      }
      return null;
  };
  function updateFuntionComponent(wip) {
      const nextChildren = renderWithHooks(wip);
      recocnileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateHostRoot(wip) {
      const baseState = wip.memoizedState;
      const updateQueue = wip.updateQueue;
      const pending = updateQueue.shared.pending;
      updateQueue.shared.pending = null;
      const { memoizedState } = processUpdateQueue(baseState, pending);
      wip.memoizedState = memoizedState;
      const nextChildren = wip.memoizedState;
      recocnileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateHostComponent(wip) {
      const nextProps = wip.pendingProps;
      const nextChildren = nextProps.child;
      recocnileChildren(wip, nextChildren);
      return wip.child;
  }
  function recocnileChildren(wip, children) {
      const current = wip.alternate;
      if (current) {
          // update
          wip.child = recocileChildFibers(wip, current?.child, children);
      }
      else {
          // mount
          wip.child = mountChildFibers(wip, null, children);
      }
  }

  // export const createInstance = (type: string, props: any): Instance => {
  const createInstance = (type) => {
      // TODO  处理props
      const element = document.createElement(type);
      return element;
  };
  const appentInitalChild = (parent, child) => {
      parent.appendChild(child);
  };
  const createTextInstance = (content) => {
      return document.createTextNode(content);
  };

  const completeWork = (wip) => {
      // 递归中的归
      const newProps = wip.pendingProps;
      const current = wip.alternate;
      switch (wip.tag) {
          case HostComponent:
              if (current && wip.stateNode) ;
              else {
                  // 构建DOM
                  const instance = createInstance(wip.type);
                  // 将DOM插入到DOM中
                  appendAllChildren(instance, wip);
                  wip.stateNode = instance;
              }
              bubblePropertise(wip);
              return null;
          case HostText:
              if (current && wip.stateNode) ;
              else {
                  // 构建DOM
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance;
              }
              bubblePropertise(wip);
              return null;
          case HostRoot:
              bubblePropertise(wip);
              return null;
          case FuntionComponent:
              bubblePropertise(wip);
              return null;
          default:
              if (__DEV__) {
                  console.warn('未处理的comleteWork情况', wip);
              }
              break;
      }
  };
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
              appentInitalChild(parent, node?.stateNode);
          }
          else if (node.child) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node?.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  function bubblePropertise(wip) {
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subtreeFlags |= subtreeFlags;
  }

  let workInProgress = null;
  function prepareFreshStack(root) {
      workInProgress = creatWorkInProgress(root.current, {});
  }
  function scheduleUpdateOnFiber(fiber) {
      // TODO 调度功能
      const root = markUpdateFormFiberToRoot(fiber);
      renderRoot(root);
  }
  function markUpdateFormFiberToRoot(fiber) {
      //节点
      let node = fiber;
      //父节点
      let parent = node.return;
      while (parent) {
          node = parent;
          parent = node.return;
      }
      if (node.tag === HostRoot) {
          return node.stateNode;
      }
      return null;
  }
  function renderRoot(root) {
      //  初始化
      prepareFreshStack(root);
      do {
          try {
              workLoop();
              break;
          }
          catch (e) {
              console.warn('workLoop发生错误', e);
              workInProgress = null;
          }
      } while (true);
      const finshedWork = root.current.alternate;
      root.finshedWork = finshedWork;
      commitRoot(root);
  }
  function commitRoot(root) {
      const finshedWork = root.finshedWork;
      if (finshedWork === null) {
          return;
      }
      if (__DEV__) {
          console.warn('commit阶段开始', finshedWork);
      }
      // 重置
      root.finshedWork = null;
      // 判断是否存在三个子阶段需要执行的操作
      // root flags root subtreeFlags
      const subtreeHasEffect = (finshedWork.subtreeFlags & MutationMask) !== NoFlags;
      const rootHasEffect = (finshedWork.flags & MutationMask) !== NoFlags;
      if (subtreeHasEffect || rootHasEffect) {
          // beforeMutation
          // mutataion  Placement
          root.current = finshedWork;
          // layout
      }
      else {
          root.current = finshedWork;
      }
  }
  function workLoop() {
      while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      const next = beginWork(fiber);
      fiber.memoizedProps = fiber.pendingProps;
      if (next === null) {
          completeUnitOfWork(fiber);
      }
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          completeWork(node);
          if (node.sibling !== null) {
              workInProgress = node.sibling;
              return;
          }
          node = node.return;
          workInProgress = node;
      } while (node !== null);
  }

  function creatContainer(container) {
      const hostRooterFiber = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, hostRooterFiber);
      hostRooterFiber.updateQueue = creatUpdateQueue();
      return root;
  }
  function updateContainer(element, root) {
      const hostRooterFiber = root.current;
      const update = creatUpdate(element);
      enqueueUpdate(hostRooterFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRooterFiber);
      return element;
  }

  function createRoot(container) {
      const root = creatContainer(container);
      return {
          render(element) {
              updateContainer(element, root);
          }
      };
  }

  var ReactDom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDom;

}));
